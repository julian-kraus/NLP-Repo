Index: dialog.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from utils import *\r\nimport keyboard\r\nimport numpy as np\r\nfrom numpy.linalg import norm\r\n\r\nspacy.cli.download(\"en_core_web_sm\")\r\nnlp = spacy.load('en_core_web_sm')\r\n\r\n\r\n\r\nclass Dialog:\r\n\r\n    def __init__(self):\r\n        self.data = data.copy()\r\n        self.history = []\r\n        self.check_data_vec = self.compute_avg_vec(check_data_questions)\r\n        print(\"Hello, I am CV-Bot. I am here to help you create your CV.\")\r\n        self.speak()\r\n\r\n    def compute_avg_vec(self, list):\r\n        vector = np.array([nlp(elem).vector for elem in list]).mean(axis=0)\r\n        return vector\r\n\r\n    def get_current_stage(self):\r\n        stage, _ = self.history[-1]\r\n        return stage\r\n\r\n    def get_previous_stage(self):\r\n        if len(self.history) > 1:\r\n            stage, _ = self.history[-1]\r\n            return stage\r\n        else:\r\n            return None  # Todo add error handling\r\n\r\n    def add_new_stage(self, position):\r\n        self.history.append((position, []))\r\n\r\n    def get_current_question(self):\r\n        _, questions = self.history[-1]\r\n        if questions:\r\n            return questions[-1]\r\n        else:\r\n            None  # Todo add error handling\r\n\r\n    def get_previous_question(self):\r\n        _, questions = self.history[-1]\r\n        if len(questions) > 1:\r\n            return questions[-2]\r\n        else:\r\n            None  # Todo add error handling\r\n\r\n    def add_question_to_history(self, question):\r\n        self.history[-1][1].append(question)\r\n\r\n    def handle_error(self, user_input, type):\r\n        if type == check_data_error:\r\n            print(\"Sorry unfortunately we couldn't find the data you were looking for.\")\r\n            new_input = input(\"Do you want to continue or try again?\")\r\n            if new_input.__contains__(\"again\"):\r\n                return self.classify(input(\"Please state your request again.\"))\r\n            else:\r\n                return None\r\n    # ask the question according to the current position\r\n    def ask(self, question):\r\n        # get the answer from the user or from the debug data\r\n        current_question = self.data[self.get_current_stage()][self.get_current_question()]\r\n        if debug:\r\n            print(current_question[question_num])\r\n            answer = debug_data[self.get_current_stage()][question]\r\n        else:\r\n            answer = input(current_question[question_num] + \"\\n\")\r\n        if debug:\r\n            print(answer)\r\n        return answer\r\n\r\n    def listen(self, input):\r\n        ...\r\n        # wait as long as keyboard is pressed\r\n\r\n    # agent starts to speak with user\r\n    def speak(self):\r\n        for position in self.data.keys():\r\n            # add the new stage to the history\r\n            self.add_new_stage(position)\r\n            # get the value of the dict of the current stage (eg, Name, Birthdate ...)\r\n            current_stage = self.data[self.get_current_stage()]\r\n            # go through all questions for the current stage, e.g. What is your name?\r\n            for question in current_stage:\r\n                self.add_question_to_history(question)\r\n                current_question = current_stage[question]\r\n                if question == \"E-Mail\" or question == \"Address\":\r\n                    processed_input = current_question[fun_num](self.ask(question))\r\n                else:\r\n                    processed_input = self.understanding(self.ask(question))\r\n                    self.map_input_to_data(processed_input)\r\n\r\n    def understanding(self, user_input):\r\n        input_type = self.classify(user_input)\r\n        if input_type == \"answer\":\r\n            return self.get_data(user_input)\r\n        else:\r\n            print_data(input_type)\r\n            return self.understanding(self.ask(self.get_current_question()))\r\n\r\n    # Possible returns are \"answer\" or the stage that is supposed to get printed\r\n    def classify(self, user_input):\r\n        user_input_vec = np.array(nlp(user_input).vector)\r\n        cosine = np.dot(user_input_vec, self.check_data_vec) / (norm(user_input_vec) * norm(self.check_data_vec))\r\n        if cosine > 0.3:\r\n            if any(e in user_input for e in check_prev):\r\n                return self.get_previous_stage()\r\n            else:\r\n                for key in self.data.keys():\r\n                    if user_input.__contains__(key):\r\n                        return key\r\n                return self.handle_error(self, user_input, check_data_error)\r\n        return \"answer\"\r\n\r\n    def get_data(self, input):\r\n        user_data = []\r\n        # check if we are only looking for regex and not the SpaCy model\r\n        current_question = self.data[self.get_current_stage()][self.get_current_question()]\r\n        necessary_entities = [element for innerList in current_question[fun_num].keys() for element in\r\n                              innerList]\r\n        doc = nlp(input)\r\n        for entity in doc.ents:\r\n            for type in necessary_entities:\r\n                if entity.label_ == type:\r\n                    user_data.append(entity.text)\r\n        print(user_data)\r\n        return user_data\r\n\r\n    # if \"DATE\" in types:\r\n    #     answer = answer.replace(\".\", \"/\")\r\n    #     answer = answer.replace(\",\", \"/\")\r\n    #\r\n    # doc = nlp(answer)\r\n    # data = []\r\n    # # filter all entities that are our searched type\r\n    # for entity in doc.ents:\r\n    #     for t in types:\r\n    #         if entity.label_ == t:\r\n    #             data.append(entity.text)\r\n    # # check if we found the correct data\r\n    # if 0 < numData != len(data):\r\n    #     data_text = \" \".join([d.text for d in data])\r\n    #     types_text = \", \".join([t for t in types])\r\n    #     doc_data_text = \" \".join([\"(\" + d.text + \", \" + d.label_ + \") \" for d in doc.ents])\r\n    #     raise Exception(\"get_data: Looked for \" + types_text + \" Found \" + str(\r\n    #         len(data)) + \"data, while expecting \" + str(\r\n    #         numData) + \" \\n The found data are \" + data_text + \"\\n the data in the doc is \" + doc_data_text)\r\n    # else:\r\n    #     return format_fun(data)\r\n\r\n    def map_input_to_data(self, user_data):\r\n        print(\"Needs to mapped\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dialog.py b/dialog.py
--- a/dialog.py	(revision dfc3c2d9778db7c4907d2b425d389c50754398f2)
+++ b/dialog.py	(date 1669470986533)
@@ -21,7 +21,7 @@
         vector = np.array([nlp(elem).vector for elem in list]).mean(axis=0)
         return vector
 
-    def get_current_stage(self):
+    def get_current_stage_name(self):
         stage, _ = self.history[-1]
         return stage
 
@@ -35,14 +35,14 @@
     def add_new_stage(self, position):
         self.history.append((position, []))
 
-    def get_current_question(self):
+    def get_current_question_name(self):
         _, questions = self.history[-1]
         if questions:
             return questions[-1]
         else:
             None  # Todo add error handling
 
-    def get_previous_question(self):
+    def get_previous_question_name(self):
         _, questions = self.history[-1]
         if len(questions) > 1:
             return questions[-2]
@@ -63,10 +63,10 @@
     # ask the question according to the current position
     def ask(self, question):
         # get the answer from the user or from the debug data
-        current_question = self.data[self.get_current_stage()][self.get_current_question()]
+        current_question = self.data[self.get_current_stage_name()][self.get_current_question_name()]
         if debug:
             print(current_question[question_num])
-            answer = debug_data[self.get_current_stage()][question]
+            answer = debug_data[self.get_current_stage_name()][question]
         else:
             answer = input(current_question[question_num] + "\n")
         if debug:
@@ -83,7 +83,7 @@
             # add the new stage to the history
             self.add_new_stage(position)
             # get the value of the dict of the current stage (eg, Name, Birthdate ...)
-            current_stage = self.data[self.get_current_stage()]
+            current_stage = self.data[self.get_current_stage_name()]
             # go through all questions for the current stage, e.g. What is your name?
             for question in current_stage:
                 self.add_question_to_history(question)
@@ -100,7 +100,7 @@
             return self.get_data(user_input)
         else:
             print_data(input_type)
-            return self.understanding(self.ask(self.get_current_question()))
+            return self.understanding(self.ask(self.get_current_question_name()))
 
     # Possible returns are "answer" or the stage that is supposed to get printed
     def classify(self, user_input):
@@ -119,7 +119,7 @@
     def get_data(self, input):
         user_data = []
         # check if we are only looking for regex and not the SpaCy model
-        current_question = self.data[self.get_current_stage()][self.get_current_question()]
+        current_question = self.data[self.get_current_stage_name()][self.get_current_question_name()]
         necessary_entities = [element for innerList in current_question[fun_num].keys() for element in
                               innerList]
         doc = nlp(input)
